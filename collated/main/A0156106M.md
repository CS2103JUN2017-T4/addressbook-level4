# A0156106M
###### /java/seedu/whatsnext/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        requireNonNull(model);
//        UnmodifiableObservableList<BasicTaskFeatures> taskList = model.getFilteredTaskList();
        try {
 //           int overlapTaskIndex = BasicTask.getOverlapTaskIndex(toAdd, taskList);
//            if (BasicTask.eventTaskOverlap(overlapTaskIndex)) {
                //BasicTaskFeatures taskToEdit = taskList.get(overlapTaskIndex);
                //model.updateTask(taskToEdit, EditCommand.createOverlappingTask(taskToEdit));
//                model.addTask(EditCommand.createOverlapTask(toAdd));
//            } else {
                model.addTask(toAdd);
//            }
//            int index = 0;
//            for (int i = 0; i < model.getFilteredTaskList().size(); i++) {
//                if (toAdd.equals(model.getFilteredTaskList().get(i))) {
//                    index = i;
//                    break;
//                }
//            }
//            EventsCenter.getInstance().post(new JumpToListRequestEvent(new Index(index)));
//            if (toAdd.containsOverlapTag()) {
//
//                String displayString = String.format(MESSAGE_SUCCESS, toAdd) + MESSAGE_OVERLAP_TASK;
//                return new CommandResult(displayString);
//            }

            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }
}
```
###### /java/seedu/whatsnext/logic/commands/ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        requireNonNull(model);
        if (clearArgument.equals(CLEAR_ALL)) {
            model.resetData(new TaskManager());
            return new CommandResult(MESSAGE_SUCCESS);
        } else if (clearArgument.equals(CLEAR_COMPLETED)) {
            return clearCompletedOrIncomplete(COMPLETED_TASKS);
        } else {
            return clearCompletedOrIncomplete(INCOMPLETE_TASKS);
        }
    }

```
###### /java/seedu/whatsnext/logic/commands/ClearCommand.java
``` java
    /**
     * Clears all completed/incomplete task based on the input parameter
     *
     * */
    private CommandResult clearCompletedOrIncomplete(boolean isCompletedOrIncomplete) {
        ReadOnlyTaskManager readOnlyTaskManager = model.getTaskManager();
        ObservableList<Tag> tagList = readOnlyTaskManager.getTagList();
        ObservableList<BasicTask> taskList = readOnlyTaskManager.getTaskList();
        TaskManager taskManager = new TaskManager();
        for (BasicTask basicTask: taskList) {
            if (isCompletedOrIncomplete ? basicTask.getIsCompleted() : !basicTask.getIsCompleted()) {
                try {
                    taskManager.addTask(basicTask);
                } catch (DuplicateTaskException e) {
                    e.printStackTrace();
                }
            }
        }

        try {
            taskManager.setTags(tagList);
        } catch (DuplicateTagException e) {
            e.printStackTrace();
        }
        model.resetData(taskManager);
        return new CommandResult(MESSAGE_SUCCESS);

    }
}
```
###### /java/seedu/whatsnext/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException, TagNotFoundException, IllegalValueException {
        List<BasicTaskFeatures> lastShownList = model.getFilteredTaskList();

        if (index.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        BasicTaskFeatures taskToEdit = lastShownList.get(index.getZeroBased());
        BasicTask editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        validateEditTask(editedTask);

        UnmodifiableObservableList<BasicTaskFeatures> taskList = model.getFilteredTaskList();

        try {

            // Check overlapping tasks still exist
            int overlapTaskIndex = BasicTask.getOverlapTaskIndex(editedTask, taskList);
            if (BasicTask.eventTaskOverlap(overlapTaskIndex)) {
                editedTask = EditCommand.createOverlapTask(editedTask);
            } else {
                // REMOVE OVERLAP TAG
            }
            model.updateTask(taskToEdit, editedTask);

        } catch (DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException pnfe) {
            throw new AssertionError("The target task cannot be missing");
        }
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
    * Checks the new editedTask created to ensure that the edited task value(s) is/are valid
    * @throws CommandException if edited task is invalid
    */
    public void validateEditTask(BasicTask editedTask) throws CommandException {
        if ((editedTask.getTaskType().equals(BasicTask.TASK_TYPE_EVENT)
                && editedTask.getEndDateTime().toString().equals(DateTime.INIT_DATETIME_VALUE))
                || (editedTask.getTaskType().equals(BasicTask.TASK_TYPE_EVENT)
                        && editedTask.getEndDateTime().isBefore(editedTask.getStartDateTime()))) {
            throw new CommandException(Messages.MESSAGE_INVALID_FLOATING_TO_EVENT_TASK);
        }
    }

```
###### /java/seedu/whatsnext/logic/commands/EditCommand.java
``` java
    /**
     * Creates a new overlapping BasicTask based on @param taskToMark
     * @return marked BasicTask
     * */
    static BasicTask createOverlapTask(BasicTaskFeatures taskToMark) {
        assert taskToMark != null;
        BasicTask toCopy = new BasicTask(taskToMark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updatedDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> copyTags = toCopy.getTags();
        Set<Tag> updatedTags = new HashSet<Tag>(copyTags);

        try {
            updatedTags.add(new Tag(Tag.RESERVED_TAG_OVERLAP));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        return new BasicTask(updatedName, updatedDescription,
                updateIsComplete, startDateTime, endDateTime, updatedTags);
    }

```
###### /java/seedu/whatsnext/logic/commands/EditCommand.java
``` java
        public void setDescription(TaskDescription description) {
            this.description = description;
        }

        public Optional<TaskDescription> getDescription() {
            return Optional.ofNullable(description);
        }

```
###### /java/seedu/whatsnext/logic/commands/MarkCommand.java
``` java
/**
 * Marks an existing task in the task manager.
 */
public class MarkCommand extends Command {
    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": marks the task identified by the index number used in the last task listing to 'completed'.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the address book.";

    private final Index targetIndex;

    public MarkCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<BasicTaskFeatures> lastShownList = model.getFilteredTaskList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        BasicTaskFeatures taskToMark = lastShownList.get(targetIndex.getZeroBased());
        BasicTask markedTask = createMarkedTask(taskToMark);
        try {
            model.updateTask(taskToMark, markedTask);
        } catch (TaskNotFoundException e) {
            throw new AssertionError("The target task cannot be missing");
        } catch (DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
    }

```
###### /java/seedu/whatsnext/logic/commands/MarkCommand.java
``` java
    /**
     * Creates a new marked BasicTask based on @param taskToMark
     * @return marked BasicTask
     * */
    private static BasicTask createMarkedTask(BasicTaskFeatures taskToMark) {
        assert taskToMark != null;
        BasicTask toCopy = new BasicTask(taskToMark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updatedDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        toCopy.setCompleted();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> updatedTags = toCopy.getTags();
        return new BasicTask(updatedName, updatedDescription, updateIsComplete, startDateTime, endDateTime, updatedTags);
    }

}
```
###### /java/seedu/whatsnext/logic/commands/UnmarkCommand.java
``` java
/**
 * Marks an existing task in the task manager.
 */
public class UnmarkCommand extends Command {
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": unmarks the task identified by the index number used in the last task listing to 'completed'.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the address book.";
    private final Index targetIndex;

    public UnmarkCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<BasicTaskFeatures> lastShownList = model.getFilteredTaskList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        BasicTaskFeatures taskToMark = lastShownList.get(targetIndex.getZeroBased());
        BasicTask markedTask = createUnmarkedTask(taskToMark);
        try {
            model.updateTask(taskToMark, markedTask);
        } catch (TaskNotFoundException e) {
            throw new AssertionError("The target task cannot be missing");
        } catch (DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        return new CommandResult(String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToMark));
    }

```
###### /java/seedu/whatsnext/logic/commands/UnmarkCommand.java
``` java
    /**
     * Creates a new unmarked BasicTask based on @param taskToUnmark
     * @return marked BasicTask
     * */
    private static BasicTask createUnmarkedTask(BasicTaskFeatures taskToUnmark) {
        assert taskToUnmark != null;
        BasicTask toCopy = new BasicTask(taskToUnmark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updateDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        toCopy.setIncomplete();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> updatedTags = toCopy.getTags();
        return new BasicTask(updatedName, updateDescription, updateIsComplete, startDateTime, endDateTime, updatedTags);
    }

}
```
###### /java/seedu/whatsnext/logic/parser/AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddCommand parse(String args) throws ParseException {
        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_MESSAGE, PREFIX_START_DATETIME,
                        PREFIX_END_DATETIME, PREFIX_TAG_CLI);

        if (!arePrefixesPresent(argMultimap)) {
            System.out.println("ARGUMENT = " + args);
            throw new ParseException(String.format("testing", AddCommand.MESSAGE_USAGE));
        }

        try {
            TaskName taskName = new TaskName(argMultimap.getPreamble());
            Optional<String> startDateTimeValue = argMultimap.getValue(PREFIX_START_DATETIME);
            Optional<String> endDateTimeValue = argMultimap.getValue(PREFIX_END_DATETIME);
            Optional<String> taskDescriptionValue = argMultimap.getValue(PREFIX_MESSAGE);
            Set<Tag> tagList = ParserUtil.parseTags(argMultimap.getAllValues(PREFIX_TAG_CLI));

            BasicTask task = createBasicTaskBasedOnInputs(taskName, taskDescriptionValue,
                    startDateTimeValue, endDateTimeValue, tagList);
            return new AddCommand(task);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * Creates the Basic Task object base on the value of startDateTimeValue and endDateTimeValue
     * @return BasicTask object
     * @throws ParseException if the user input does not conform the expected format
     */
    private BasicTask createBasicTaskBasedOnInputs(
            TaskName taskName, Optional<String> taskDescriptionValue, Optional<String> startDateTimeValue,
            Optional<String> endDateTimeValue, Set<Tag> tagList) throws IllegalValueException {
        BasicTask task;
        TaskDescription taskDescription = new TaskDescription();
        if (taskDescriptionValue.isPresent()) {
            taskDescription = new TaskDescription(taskDescriptionValue.get());
        }
        // Create Event Task
        if (startDateTimeValue.isPresent() && endDateTimeValue.isPresent()) {
            DateTime startDateTime = new DateTime(startDateTimeValue.get());
            DateTime endDateTime = new DateTime(endDateTimeValue.get());
            validateStartEndDateTime(startDateTime, endDateTime);
            task = new BasicTask(taskName, taskDescription, false, startDateTime, endDateTime, tagList);
        // Create Deadline Task
        } else if (endDateTimeValue.isPresent()) {
            DateTime endDateTime = new DateTime(endDateTimeValue.get());
            task = new BasicTask(taskName, taskDescription, false, endDateTime, tagList);
        // Invalid Task
        } else if (startDateTimeValue.isPresent() && !endDateTimeValue.isPresent()) {
            throw new IllegalValueException(AddCommand.INVALID_TASK_CREATED);
        // Create Floating Task
        } else {
            task = new BasicTask(taskName, taskDescription, false, tagList);
        }
        return task;
    }

    private void validateStartEndDateTime(DateTime startDateTime, DateTime endDateTime) throws IllegalValueException {
        if (!startDateTime.isBefore(endDateTime)) {
            throw new IllegalValueException(AddCommand.INVALID_TASK_CREATED);
        }
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }

}
```
###### /java/seedu/whatsnext/logic/parser/ClearCommandParser.java
``` java
/**
 * Parse input arguments and creates a new ClearCommand Object
 * */
public class ClearCommandParser {

    /**
     * Parse the given {@code String} of arguments in the context of the ClearCommand
     * and returns a ClearCommand object for execution
     * @throws ParseException if the user input does not conform the expected format
     * */
    public ClearCommand parse(String args) throws ParseException {
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(args);

        try {
            String clearArgument = argMultimap.getPreamble().trim();
            if (!isArgumentValidPrefixesPresent(clearArgument)) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
            }
            return new ClearCommand(clearArgument);

        } catch (IllegalValueException ive) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
        }
    }

    private boolean isArgumentValidPrefixesPresent(String clearArgument) {
        return clearArgument.matches(".*\\b(completed|incomplete|all)\\b.*");
    }
}
```
###### /java/seedu/whatsnext/logic/parser/CliSyntax.java
``` java
    public static final Prefix PREFIX_DESCRIPTION = new Prefix("m/");
    public static final Prefix PREFIX_TO = new Prefix("to");
    public static final Prefix PREFIX_ON = new Prefix("on");
    public static final Prefix PREFIX_ALL = new Prefix("all");
    public static final Prefix PREFIX_COMPLETED = new Prefix("completed");
    public static final Prefix PREFIX_INCOMPLETE = new Prefix("incomplete");

```
###### /java/seedu/whatsnext/logic/parser/MarkCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns a MarkCommand object for execution
     * @throws ParseException if the user input does not confirm the expected format
     * */
    public MarkCommand parseMarkCommand(String args) throws ParseException {
        try {
            Index index = ParserUtil.parseIndex(args);
            return new MarkCommand(index);
        } catch (IllegalValueException ive) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
    }

    public UnmarkCommand parseUnmarkCommand(String args) throws ParseException {
        try {
            Index index = ParserUtil.parseIndex(args);
            return new UnmarkCommand(index);
        } catch (IllegalValueException ive) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case AddCommand.COMMAND_WORD:
            return new AddCommandParser().parse(arguments);

        case EditCommand.COMMAND_WORD:
            return new EditCommandParser().parse(arguments);

        case SelectCommand.COMMAND_WORD:
            return new SelectCommandParser().parse(arguments);

        case DeleteCommand.COMMAND_WORD:
            return new DeleteCommandParser().parse(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case MarkCommand.COMMAND_WORD:
            return new MarkCommandParser().parseMarkCommand(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case UnmarkCommand.COMMAND_WORD:
            return new MarkCommandParser().parseUnmarkCommand(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case ClearCommand.COMMAND_WORD:
            return new ClearCommandParser().parse(arguments);

        case FindCommand.COMMAND_WORD:
            return new FindCommandParser().parse(arguments);

```
###### /java/seedu/whatsnext/logic/parser/ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<String> parseType(Optional<String> name) throws IllegalValueException {
        requireNonNull(name);
        return name.isPresent() ? Optional.of(new String(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<TaskDescription> parseDescription(Optional<String> description)
            throws IllegalValueException {
        requireNonNull(description);
        return description.isPresent() ? Optional.of(new TaskDescription(description.get())) : Optional.empty();
    }


    /**
     * Parses {@code Collection<String> tags} into a {@code Set<Tag>}.
     */
    public static Set<Tag> parseTags(Collection<String> tags) throws IllegalValueException {
        requireNonNull(tags);
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            if (isPriorityTagString(tagName)) {
                tagSet.add(new Tag(tagName.trim()));
                break;
            }
        }

        for (String tagName : tags) {
            if (!isPriorityTagString(tagName)) {
                tagSet.add(new Tag(tagName.trim()));
            }
        }
        return tagSet;
    }

```
###### /java/seedu/whatsnext/logic/parser/ParserUtil.java
``` java
    /**
     * Parses {@code Optional<String> tags} into a {@code Set<Tag>}.
     * @return {@code Set<tag>} which represent all tags
     */
    public static Set<Tag> parseMultipleTags(Optional<String> tagStringInput) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        if (tagStringInput.isPresent()) {
            String tagString = tagStringInput.get();
            String[] tagList = tagString.split(" ");
            for (String tagName : tagList) {
                tagSet.add(new Tag(tagName.trim()));
            }
        }
        return tagSet;
    }

    private static boolean isPriorityTagString(String tagName) {
        return tagName.toUpperCase().equals(HIGH)
              || tagName.toUpperCase().equals(MEDIUM)
              || tagName.toUpperCase().equals(LOW);

    }

}
```
###### /java/seedu/whatsnext/model/tag/UniqueTagList.java
``` java
    /**
     * Returns true if the list contains priority "OVERLAP" tag
     * */
    public boolean containsOverlapTag() throws IllegalValueException {
        final Tag overlapTag = new Tag(Tag.RESERVED_TAG_OVERLAP);
        return internalList.contains(overlapTag);
    }

```
###### /java/seedu/whatsnext/model/task/BasicTask.java
``` java
/**
 * Represents a Basic Task in the WhatsNext application.
 * Basic Tasks are only able to store task name, task description and tags
 * Guarantees: details are present and not null, field values are validated.
 */
public class BasicTask implements BasicTaskFeatures {
    public static final String TASK_TYPE_FLOATING = "floating";
    public static final String TASK_TYPE_DEADLINE = "deadline";
    public static final String TASK_TYPE_EVENT = "event";
    private DateTime startDateTime;
    private DateTime endDateTime;
    private String taskType;
    private TaskName taskName;
    private TaskDescription taskDescription;
    private boolean isCompleted;
    private UniqueTagList tags;


    /**
     * Constructor for Floating
     * Deadline consists of Name, End Date, End Time and tags
     * @throws IllegalValueException
     * */

    /**
     * Constructor for Floating
     * @throws IllegalValueException
     * */
    public BasicTask(TaskName taskName, TaskDescription taskDescription, boolean isCompleted, Set<Tag> tags) throws IllegalValueException {
        this (taskName, taskDescription, isCompleted, new DateTime(), new DateTime(), tags);
    }

    public BasicTask(TaskName taskName, TaskDescription taskDescription, Set<Tag> tags) throws IllegalValueException {
        this (taskName, taskDescription, false, new DateTime(), new DateTime(), tags);
    }

    public BasicTask(TaskName taskName, Set<Tag> tags) throws IllegalValueException {
        this (taskName, new TaskDescription(), false, new DateTime(), new DateTime(), tags);
    }

    /**
     * Constructor for Deadline
     * @throws IllegalValueException
     * */
    public BasicTask(TaskName taskName, TaskDescription taskDescription, DateTime endDateTime, Set<Tag> tags)
            throws IllegalValueException {
        this (taskName, taskDescription, false, new DateTime(), endDateTime, tags);
    }

    public BasicTask(TaskName taskName, TaskDescription taskDescription, boolean isCompleted, DateTime endDateTime, Set<Tag> tags)
            throws IllegalValueException {
        this (taskName, taskDescription, isCompleted, new DateTime(), endDateTime, tags);
    }

    public BasicTask(TaskName taskName, TaskDescription taskDescription, DateTime startDateTime, DateTime endDateTime, Set<Tag> tags)
            throws IllegalValueException {
        this (taskName, taskDescription, false, startDateTime, endDateTime, tags);
    }

    /**
     * Constructor for Event
     * @throws IllegalValueException
     * */
    public BasicTask(TaskName taskName, TaskDescription taskDescription, boolean isCompleted,
            DateTime startDateTime, DateTime endDateTime, Set<Tag> tags) {
        //assert (startDateTime.isEmpty() && !endDateTime.isEmpty());
        this.taskName = taskName;
        this.taskDescription = taskDescription;
        this.tags = new UniqueTagList(tags);
        this.isCompleted = isCompleted;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        setTaskType();
    }

    public BasicTask(BasicTaskFeatures source) {
        this (source.getName(), source.getDescription(), source.getIsCompleted(),
                source.getStartDateTime(), source.getEndDateTime(), source.getTags());
    }

    public void setTaskType() {
        if (this.startDateTime.isEmpty() && this.endDateTime.isEmpty()) {
            taskType = TASK_TYPE_FLOATING;
        } else if (this.startDateTime.isEmpty() && !this.endDateTime.isEmpty()) {
            taskType = TASK_TYPE_DEADLINE;
        } else {
            taskType = TASK_TYPE_EVENT;
        }
    }

    @Override
    public boolean eventTaskOverlap(BasicTaskFeatures task) {
        return (this.getTaskType().equals(TASK_TYPE_EVENT) && task.getTaskType().equals(TASK_TYPE_EVENT)
                && this.getStartDateTime().isBeforeOrEqual(task.getEndDateTime())
                && task.getStartDateTime().isBeforeOrEqual(this.getEndDateTime()));

    }

    public void setName(TaskName name) {
        this.taskName = requireNonNull(name);
    }

    public void setDescription(TaskDescription description) {
        this.taskDescription = requireNonNull(description);
    }

    @Override
    public TaskName getName() {
        return taskName;
    }

    /**
     * Returns an immutable tag set, which throws {@code UnsupportedOperationException}
     * if modification is attempted.
     */
    @Override
    public Set<Tag> getTags() {
        return Collections.unmodifiableSet(tags.toSet());
    }

    /**
     * Replaces this task's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.setTags(new UniqueTagList(replacement));
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(BasicTaskFeatures replacement) {
        requireNonNull(replacement);
        this.setName(replacement.getName());
        this.setTags(replacement.getTags());
        this.setDescription(replacement.getDescription());
        this.isCompleted = (replacement.getIsCompleted());
        this.startDateTime = (replacement.getStartDateTime());
        this.endDateTime = (replacement.getEndDateTime());
        setTaskType();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof BasicTaskFeatures // instanceof() handles nulls
                && this.isSameStateAs((BasicTaskFeatures) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean getIsCompleted() {
        return isCompleted;
    }


    @Override
    public void setCompleted() {
        isCompleted = true;
    }

    @Override
    public void setIncomplete() {
        isCompleted = false;
    }

    @Override
    public DateTime getStartDateTime() {
        return startDateTime;
    }

    @Override
    public DateTime getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String getTaskType() {
        return taskType;
    }

    @Override
    public String getStatusString() {
        if (getIsCompleted()) {
            return "Completed";
        } else {
            return "Incomplete";
        }
    }

    @Override
    public void setStartDateTime(DateTime dateTime) {
        startDateTime = dateTime;
        setTaskType();
    }

    @Override
    public void setEndDateTime(DateTime dateTime) {
        endDateTime = dateTime;
        setTaskType();
    }

    @Override
    public TaskDescription getDescription() {
        return taskDescription;
    }

    public static boolean eventTaskOverlap(int overlapIndex) {
        return overlapIndex != -1;
    }

    public static int getOverlapTaskIndex(BasicTaskFeatures taskToEdit, UnmodifiableObservableList<BasicTaskFeatures> taskList) {
        int index = 0;
        for (BasicTaskFeatures task : taskList) {
            if (taskToEdit.eventTaskOverlap(task) && (!taskToEdit.equals(task))) {
                return index;
            }
        }
        return -1;
    }

    public boolean containsOverlapTag() throws IllegalValueException  {
        return tags.containsOverlapTag();
    }

    @Override
    public String getTaskDetails() {
        StringBuilder details = new StringBuilder();
        if (this.getTaskType().equals("event")) {
            details.append("Task name: " + this.getName() + "\n"
                + "Tags: " + this.getAllTags() + "\n"
                + "Status: " + this.getStatusString() + "\n"
                + "From: " + this.getStartDateTime().toString() + " "
                + "To: " + this.getEndDateTime().toString() + "\n"
                + "Description: " + this.getDescription().toString());
        } else if (this.getTaskType().equals("deadline")) {
            details.append("Task name: " + this.getName() + "\n"
                    + "Tags: " + this.getAllTags() + "\n"
                    + "Status: " + this.getStatusString() + "\n"
                    + "Due by: " + this.getEndDateTime().toString() + "\n"
                    + "Description: " + this.getDescription().toString());
        } else if (this.getTaskType().equals("floating")) {
            details.append("Task name: " + this.getName() + "\n"
                    + "Tags: " + this.getAllTags() + "\n"
                    + "Status: " + this.getStatusString() + "\n"
                    + "Description: " + this.getDescription().toString());
        }
        return details.toString();
    }

}
```
###### /java/seedu/whatsnext/model/task/BasicTaskFeatures.java
``` java
 */
public interface BasicTaskFeatures {

    TaskName getName();
    TaskDescription getDescription();
    Set<Tag> getTags();
    boolean getIsCompleted();
    void setCompleted();
    void setIncomplete();
    void setStartDateTime(DateTime dateTime);
    void setEndDateTime(DateTime dateTime);
    DateTime getStartDateTime();
    DateTime getEndDateTime();
    String getTaskType();
    String getStatusString();
    String getTaskDetails();


    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(BasicTaskFeatures other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName())); // state checks here onwards
    }

    /**
     * Formats the task as text, showing all task details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
               .append(" Tags: ");
        builder.append(getAllTags());
        return builder.toString();
    }

    default String getAllTags() {
        final StringBuilder builder = new StringBuilder();
        Iterator<Tag> tag = getTags().iterator();
        while (tag.hasNext()) {
            Tag tagToBeDisplayed = tag.next();
            if (tagToBeDisplayed.isPriorityTag()) {
                builder.append("[" + tagToBeDisplayed.tagName + "] ");
            }
        }

        tag = getTags().iterator();
        while (tag.hasNext()) {
            Tag tagToBeDisplayed = tag.next();
            if (!tagToBeDisplayed.isPriorityTag()) {
                builder.append("[" + tagToBeDisplayed.tagName + "] ");
            }
        }

        return builder.toString();
    }
    boolean eventTaskOverlap(BasicTaskFeatures task);


}
```
###### /java/seedu/whatsnext/model/task/DateTime.java
``` java
/**
 * Represents the Date of a BasicTask
 *
 * */
public class DateTime {
    public static final String INIT_DATETIME_VALUE = "0001/01/01 00:00";
    public static final String DEFAULT_TIME_VALUE = " 23:59";
    public static final String MESSAGE_DATE_CONSTRAINT = "Task date should be either "
            + "a day (e.g. friday) or a date with the format: DD/MM/YY (e.g. 06/07/17)\n";
    public static final String MESSAGE_DATE_INVALID = "A Task cannot be created before today.";

    private final DateFormat dateTimeFormat = new SimpleDateFormat("yyyy/dd/MM HH:mm");
    private final DateFormat dateFormat = new SimpleDateFormat("yyyy/dd/MM");
    private final DateFormat timeFormat = new SimpleDateFormat("HH:mm");
    private Date dateValue;

    public DateTime() throws IllegalValueException {
        this(INIT_DATETIME_VALUE);
    }

    public DateTime(String dateInput) throws IllegalValueException {
        assert(dateInput != null);
        String dateInputTrim = dateInput.trim();
        initDateValue(dateInputTrim);
    }

    /**
     * Initializes the dateValue object variable base on its input parameters
     *
     * */
    private void initDateValue(String dateInputTrim) throws IllegalValueException {
        if (dateInputTrim.equals(INIT_DATETIME_VALUE)) {
            try {
                dateValue = dateTimeFormat.parse(INIT_DATETIME_VALUE);
            } catch (java.text.ParseException e) {
                e.printStackTrace();
            }
        } else {
            List<Date> dateInputList = new PrettyTimeParser().parse(dateInputTrim);
            if (!isValidDate(dateInputList)) {
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINT);
            }
            dateValue = dateInputList.get(0);
            validateDateTime();
        }
    }

    /**
     * Prevents User from setting Tasks before today
     * @throws IllegalValueException when dateValue is before today's date
     * */
    private void validateDateTime() throws IllegalValueException {
        Date today = new Date();
        if (timeFormat.format(today).equals(getTime())) {
            String tempDateValue = getDate() + DEFAULT_TIME_VALUE;
            try {
                dateValue = dateTimeFormat.parse(tempDateValue);
                if (isBefore(today)) {
                    throw new IllegalValueException(MESSAGE_DATE_INVALID);
                }
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Checks if the list is empty
     * */
    private boolean isValidDate(List<Date> dateInputList) {
        return !dateInputList.isEmpty();
    }

    public String getDate() {
        return dateFormat.format(dateValue);
    }

    public String getTime() {
        return timeFormat.format(dateValue);
    }

    @Override
    public String toString() {
        return dateTimeFormat.format(dateValue);
    }

    public boolean equals(DateTime other) {
        return this.toString().equals(other.toString());
    }

    /**
     * @return true if dateValue is before parameter
     * */
    public boolean isBefore(DateTime endDateTime) {
        // dateValue is before source
        return dateValue.compareTo(endDateTime.dateValue) < 0;
    }

    public boolean isBefore(Date endDate) {
        // dateValue is before source
        return dateValue.compareTo(endDate) < 0;
    }

    /**
     * @return true when dateValue is equal or after source's dateValue
     * */
    public boolean isAfterOrEqual(DateTime source) {
        // dateValue is after or equal source
        return dateValue.compareTo(source.dateValue) >= 0;
    }

    /**
     * @return true when dateValue is equal or before source's dateValue
     * */
    public boolean isBeforeOrEqual(DateTime source) {
        // dateValue is before or equal source
        return dateValue.compareTo(source.dateValue) <= 0;
    }

    /**
     * @return true when DateValue contains INIT_DATETIME_VALUE
     * */
    public boolean isEmpty() {
        return toString().equals(INIT_DATETIME_VALUE);
    }

}
```
###### /java/seedu/whatsnext/model/task/TaskDescription.java
``` java
/**
 * Represents a Task's name in the WhatsNext application.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */

public class TaskDescription {
    public static final String INIT_DECRIPTION_VALUE = "Empty";
    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task description should only contain alphanumeric characters and spaces";
    /*
     * The first character of the task must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String TASK_DESCRIPTION_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";
    public final String fullTaskDescription;

    public TaskDescription() throws IllegalValueException {
        this (INIT_DECRIPTION_VALUE);
    }

    /**
     * Validates given Description.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskDescription(String description) throws IllegalValueException {
        requireNonNull(description);
        String trimmedDescription = description.trim();
        if (!isValidDescription(trimmedDescription)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullTaskDescription = trimmedDescription;
    }

    /**
     * Returns true if a given string is a valid person name.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(TASK_DESCRIPTION_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return fullTaskDescription;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDescription // instanceof handles nulls
                && this.fullTaskDescription.equals(((TaskDescription) other).fullTaskDescription)); // state check
    }

    @Override
    public int hashCode() {
        return fullTaskDescription.hashCode();
    }
}
```
###### /java/seedu/whatsnext/model/task/TaskName.java
``` java
/**
 * Represents a Task's name in the WhatsNext application.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class TaskName {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the task must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String TASKNAME_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String fullTaskName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskName(String name) throws IllegalValueException {
        requireNonNull(name);
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullTaskName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(TASKNAME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return fullTaskName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskName // instanceof handles nulls
                && this.fullTaskName.equals(((TaskName) other).fullTaskName)); // state check
    }

    @Override
    public int hashCode() {
        return fullTaskName.hashCode();
    }

}
```
###### /java/seedu/whatsnext/model/util/SampleDataUtil.java
``` java
    public static BasicTask[] getSampleData() throws IllegalValueException {
        BasicTask[] sampleData = {
            // Floating Tasks
            new BasicTask(new TaskName("Buy Ice Cream"),
                    new TaskDescription("Buy 2 tubs of chocolate ice cream"), getTagSet("groceries")),
            new BasicTask(new TaskName("Buy some beer"),
                    new TaskDescription(), getTagSet("groceries")),
            new BasicTask(new TaskName("Buy Coffee"),
                    new TaskDescription("Buy coffee to complete CS2103 project"), getTagSet("groceries")),
            new BasicTask(new TaskName("Buy a new TV"),
                    new TaskDescription(), getTagSet("TV")),
            new BasicTask(new TaskName("Buy new Chair"),
                    new TaskDescription("Buy a new chair from ikea"), getTagSet("chair")),
            new BasicTask(new TaskName("Build a new Chair"),
                    new TaskDescription("Build a new Chair from scratch"), getTagSet("chair")),
            new BasicTask(new TaskName("BTO"), new TaskDescription("Build To Order"), getTagSet("house")),
            new BasicTask(new TaskName("Try again for BTO"),
                    new TaskDescription(), getTagSet("house")),
            new BasicTask(new TaskName("Give up on BTO"),
                    new TaskDescription(), getTagSet("house")),
            new BasicTask(new TaskName("Rent a house"),
                    new TaskDescription("Rent a house for life"), getTagSet("house")),
            new BasicTask(new TaskName("Build a house"), new TaskDescription("Build own house"), getTagSet("house")),
            new BasicTask(new TaskName("Buy a car"), new TaskDescription("Get a new car"), getTagSet("car")),
            new BasicTask(new TaskName("Buy a boat"), new TaskDescription("Get a new boat"), getTagSet("boat")),
            new BasicTask(new TaskName("Buy a bicycle"), new TaskDescription("Get a new bicycle"), getTagSet()),
            new BasicTask(new TaskName("Buy a tricycle"),
                    new TaskDescription("No money get a tricycle instead"), getTagSet()),
            // Deadline Task
            new BasicTask(new TaskName("CS2103 assignment"),
                    new TaskDescription("Complete CS2103 assignment"),
                    new DateTime("next Monday"), getTagSet("CS2103")),
            new BasicTask(new TaskName("Go to the Gym"),
                    new TaskDescription(), new DateTime("next Monday"), getTagSet("gym")),
            new BasicTask(new TaskName("Basketball tournament"),
                    new TaskDescription(), new DateTime("next tuesday, 6pm"), getTagSet("basketball")),
            new BasicTask(new TaskName("Soccer competition"),
                    new TaskDescription(), new DateTime("following monday, 7am"), getTagSet("soccer")),
            new BasicTask(new TaskName("Samuel Birthday"),
                    new TaskDescription(), new DateTime("following friday"), getTagSet("birthday")),
            new BasicTask(new TaskName("Buy beer for BBQ"), new TaskDescription("Buy beer for Jacks birthday party"),
                    new DateTime("next friday"), getTagSet("BBQ")),
            new BasicTask(new TaskName("BBQ at Jacks house"),
                    new TaskDescription("Jacks birthday party"), new DateTime("next friday"), getTagSet("BBQ")),
            new BasicTask(new TaskName("Wedding Anniversary"),
                    new TaskDescription(), new DateTime("next Sunday"), getTagSet("annivesary")),
            new BasicTask(new TaskName("Dentist Appointment"), new TaskDescription("Clean teeth"),
                    new DateTime("next sunday, 1am"), getTagSet("dental", "doctor")),
            new BasicTask(new TaskName("Doctor Appointment"),
                    new TaskDescription("physiotherapy"), new DateTime("following sunday, 1pm"), getTagSet("doctor")),
            new BasicTask(new TaskName("Lunch with John"),
                    new TaskDescription("lunch at some restaurant with john"),
                    new DateTime("following monday, 12pm"), getTagSet("lunch", "food")),
            new BasicTask(new TaskName("Dinner with Jack"),
                    new TaskDescription("dinner at some restaurant with jack"),
                    new DateTime("following tuesday, 6pm"), getTagSet("dinner", "food")),
            new BasicTask(new TaskName("Project Meeting"),
                    new TaskDescription("CS2103 project meeting with teammates"),
                    new DateTime("following weds, 6pm"), getTagSet("CS2103", "NUS")),
            new BasicTask(new TaskName("Get Ready for School"),
                    new TaskDescription(), new DateTime("following weds, 12pm"), getTagSet("CS2103", "NUS")),
            new BasicTask(new TaskName("FYP selection"), new TaskDescription("Select FYP project"),
                    new DateTime("following friday, 12pm"), getTagSet("FYP", "NUS")),
            new BasicTask(new TaskName("Bid for modules"), new TaskDescription("Module bidding"),
                    new DateTime("3 weeks from now, 8am"), getTagSet("modules", "NUS")),
            new BasicTask(new TaskName("Bid for tutorials"), new TaskDescription("Tutorial bidding"),
                    new DateTime("4 weeks from now, 8am"), getTagSet("tutorials", "NUS")),
            new BasicTask(new TaskName("Withdraw from school"),
                    new TaskDescription("Select FYP project"), new DateTime("5 weeks from now, 8am"), getTagSet("NUS")),
            new BasicTask(new TaskName("Christmas"),
                    new TaskDescription(), new DateTime("25 December"), getTagSet("holiday")),
            new BasicTask(new TaskName("Christmas Party at work"),
                    new TaskDescription(), new DateTime("23 December"), getTagSet("holiday")),
            // Event Task
            new BasicTask(new TaskName("Rest for the day"), new TaskDescription("Sleep the entire day away"),
                    new DateTime("next monday 12am"), new DateTime("next monday 1159pm"), getTagSet("rest")),
            new BasicTask(new TaskName("Meet prof"), new TaskDescription("Project stuff"),
                    new DateTime("1 week from now, 12pm"), new DateTime("1 week from now, 1pm"), getTagSet("project")),
            new BasicTask(new TaskName("Revise for midterms"), new TaskDescription("Revision for midterms"),
                    new DateTime("20 August"), new DateTime("25 August"), getTagSet("midterms")),
            new BasicTask(new TaskName("John getting married"), new TaskDescription("Wedding dinner at some hotel"),
                    new DateTime("1 week from now, 6pm"), new DateTime("1 week from now, 9pm"), getTagSet("wedding")),
            new BasicTask(new TaskName("John bachelor party"), new TaskDescription("Bachelor party at some place"),
                    new DateTime("next monday, 6pm"), new DateTime("next tuesday, 4am"), getTagSet("wedding")),
            new BasicTask(new TaskName("John getting divorce"), new TaskDescription("Go to court for settlement"),
                    new DateTime("following friday, 8am"),
                    new DateTime("following friday, 10am"), getTagSet("wedding")),
            new BasicTask(new TaskName("John getting remarried"), new TaskDescription("Wedding dinner at some hotel"),
                    new DateTime("11 August 2018, 6pm"), new DateTime("11 August 2018, 9pm"), getTagSet("wedding")),
            new BasicTask(new TaskName("CS2103 Project meeting"), new TaskDescription("Project meeting for CS2103"),
                    new DateTime("next tuesday 8am"), new DateTime("next tues 10am"), getTagSet("nus", "CS2103")),
            new BasicTask(new TaskName("Exam Period"), new TaskDescription("Final Exam Period"),
                    new DateTime("11 Dec 2017"),
                    new DateTime("20 Dec 2017"), getTagSet("nus", "exam")),
            new BasicTask(new TaskName("Study Break"),
                    new TaskDescription("Study break before Exams"), new DateTime("1 Dec 2017"),
                    new DateTime("10 Dec 2017"), getTagSet("nus", "exam")),
            new BasicTask(new TaskName("Winter Vacation"),
                    new TaskDescription("Post Exam vacation to Europe"), new DateTime("11 Dec 2017"),
                    new DateTime("30 Dec 2017"), getTagSet("holiday")),
            new BasicTask(new TaskName("Internship"),
                    new TaskDescription(), new DateTime("1 Jan 2018"),
                    new DateTime("1 March 2018"), getTagSet("intern")),
            new BasicTask(new TaskName("Meet some frieds"), new TaskDescription(),
                    new DateTime("next friday 2pm"), new DateTime("next friday 4pm"), getTagSet("meeting")),
            new BasicTask(new TaskName("Watch movie"), new TaskDescription(),
                    new DateTime("next friday 5pm"), new DateTime("next friday 7pm"), getTagSet("movie")),
            new BasicTask(new TaskName("Drinks with friends"), new TaskDescription(),
                    new DateTime("next friday 11pm"), new DateTime("next friday 2am"), getTagSet("meeting")),

        };
        return sampleData;
    }



}
```
###### /java/seedu/whatsnext/storage/XmlAdaptedTask.java
``` java
    /**
     * Converts this jaxb-friendly adapted person object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public BasicTask toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final TaskName name = new TaskName(this.name);
        final boolean isCompleted = this.isCompleted;
        final Set<Tag> tags = new HashSet<>(taskTags);
        final DateTime startDateTime;
        final DateTime endDateTime;
        TaskDescription taskDescription = new TaskDescription();
        if (this.taskDescription != null) {
            taskDescription = new TaskDescription(this.taskDescription);
        }

        // Event Task
        if (this.startDateTime != null && this.endDateTime != null) {
            startDateTime = new DateTime(this.startDateTime);
            endDateTime = new DateTime(this.endDateTime);
            return new BasicTask(name, taskDescription, isCompleted, startDateTime, endDateTime, tags);
        } else if (this.endDateTime != null) {
            endDateTime = new DateTime(this.endDateTime);
            return new BasicTask(name, taskDescription, isCompleted, endDateTime, tags);
        } else {
            return new BasicTask(name, taskDescription, isCompleted, tags);
        }

    }
}
```
